local ffi = require("ffi")
local base = require("resty.core.base")

local math_floor = math.floor
local get_string_buf = base.get_string_buf

-- From: https://github.com/openresty/lua-resty-signal/blob/master/lib/resty/signal.lua
local load_shared_lib
do
    local tostring = tostring
    local string_gmatch = string.gmatch
    local string_match = string.match
    local io_open = io.open
    local io_close = io.close
    local table_new = require("table.new")

    local cpath = package.cpath

    function load_shared_lib(so_name)
        local tried_paths = table_new(32, 0)
        local i = 1

        for k, _ in string_gmatch(cpath, "[^;]+") do
            local fpath = tostring(string_match(k, "(.*/)"))
            fpath = fpath .. so_name
            -- Don't get me wrong, the only way to know if a file exist is
            -- trying to open it.
            local f = io_open(fpath)
            if f ~= nil then
                io_close(f)
                return ffi.load(fpath, true)
            end

            tried_paths[i] = fpath
            i = i + 1
        end

        return nil, tried_paths
    end  -- function
end  -- do

local lib_name = ffi.os == "OSX" and "libresty_protobuf.dylib" or "libresty_protobuf.so"

local clib, tried_paths = load_shared_lib(lib_name)
if not clib then
    error(("could not load %s shared library from the following paths:\n"):format(lib_name) ..
          table.concat(tried_paths, "\n"), 2)
end

-- generated by `cbindgen -c cbindgen.toml`
ffi.cdef([[
    /* Generated by cbindgen.  Do NOT edit. */
    
    typedef struct Logs Logs;
    
    typedef struct Metrics Metrics;
    
    typedef struct Traces Traces;
    
    struct Traces *lua_resty_protobuf_trace_new(void);
    
    unsigned int lua_resty_protobuf_trace_get_serialized(struct Traces *traces,
                                                         unsigned char *buf,
                                                         unsigned int buf_len);
    
    int lua_resty_protobuf_trace_enter_span(struct Traces *traces,
                                            const char *name,
                                            unsigned int name_len,
                                            unsigned char *err_buf,
                                            unsigned int err_buf_len);
    
    void lua_resty_protobuf_trace_exit_span(struct Traces *traces);
    
    int lua_resty_protobuf_trace_add_string_attribute(struct Traces *traces,
                                                      const char *key,
                                                      unsigned int key_len,
                                                      const char *value,
                                                      unsigned int value_len,
                                                      unsigned char *err_buf,
                                                      unsigned int err_buf_len);
    
    int lua_resty_protobuf_trace_add_bool_attribute(struct Traces *traces,
                                                    const char *key,
                                                    unsigned int key_len,
                                                    int value,
                                                    unsigned char *err_buf,
                                                    unsigned int err_buf_len);
    
    int lua_resty_protobuf_trace_add_int64_attribute(struct Traces *traces,
                                                     const char *key,
                                                     unsigned int key_len,
                                                     long long value,
                                                     unsigned char *err_buf,
                                                     unsigned int err_buf_len);
    
    int lua_resty_protobuf_trace_add_double_attribute(struct Traces *traces,
                                                      const char *key,
                                                      unsigned int key_len,
                                                      double value,
                                                      unsigned char *err_buf,
                                                      unsigned int err_buf_len);
    
    struct Metrics *lua_resty_protobuf_metrics_new(void);
    
    unsigned int lua_resty_protobuf_metrics_get_serialized(struct Metrics *metrics,
                                                         unsigned char *buf,
                                                         unsigned int buf_len);
    
    int lua_resty_protobuf_metrics_add_gauge(struct Metrics *metrics,
                                             const char *name,
                                             unsigned int name_len,
                                             long long value,
                                             unsigned char *err_buf,
                                             unsigned int err_buf_len);
    
    int lua_resty_protobuf_metrics_add_sum(struct Metrics *metrics,
                                           const char *name,
                                           unsigned int name_len,
                                           long long value,
                                           unsigned char *err_buf,
                                           unsigned int err_buf_len);
    
    struct Logs *lua_resty_protobuf_logs_new(void);
    
    unsigned int lua_resty_protobuf_logs_get_serialized(struct Logs *logs,
                                                        unsigned char *buf,
                                                        unsigned int buf_len);
    
    int lua_resty_protobuf_logs_add_info(struct Logs *logs,
                                         unsigned long long time_unix_nano,
                                         const char *message,
                                         unsigned int message_len,
                                         unsigned char *err_buf,
                                         unsigned int err_buf_len);
    
    int lua_resty_protobuf_logs_add_warn(struct Logs *logs,
                                         unsigned long long time_unix_nano,
                                         const char *message,
                                         unsigned int message_len,
                                         unsigned char *err_buf,
                                         unsigned int err_buf_len);
    
    int lua_resty_protobuf_logs_add_error(struct Logs *logs,
                                          unsigned long long time_unix_nano,
                                          const char *message,
                                          unsigned int message_len,
                                          unsigned char *err_buf,
                                          unsigned int err_buf_len);
    
    int lua_resty_protobuf_logs_add_fatal(struct Logs *logs,
                                          unsigned long long time_unix_nano,
                                          const char *message,
                                          unsigned int message_len,
                                          unsigned char *err_buf,
                                          unsigned int err_buf_len);
]])


local _M = {}

return {
    clib = clib,
}



-- function _M.new()
--     local handle = clib.lua_resty_protobuf_trace_new()

--     -- avoid tail call
--     return handle
-- end

-- function _M.free(handle)
--     clib.lua_resty_protobuf_trace_free(handle)
-- end

-- function _M.enter_span(handle, name)
--     local err_buf = get_string_buf(ERROR_BUF_LEN)
--     local rc = clib.lua_resty_protobuf_trace_enter_span(handle, name, #name, err_buf, ERROR_BUF_LEN)

--     if rc ~= 0 then
--         return false, ffi.string(err_buf)
--     end

--     return true
-- end

-- function _M.add_string_attribute(handle, name, val)
--     local err_buf = get_string_buf(ERROR_BUF_LEN)
--     local rc = clib.lua_resty_protobuf_trace_add_string_attribute(handle, name, #name, val, #val, err_buf, ERROR_BUF_LEN)

--     if rc ~= 0 then
--         return false, ffi.string(err_buf)
--     end

--     return true
-- end

-- function _M.add_bool_attribute(handle, name, val)
--     local err_buf = get_string_buf(ERROR_BUF_LEN)
--     local rc = clib.lua_resty_protobuf_trace_add_bool_attribute(handle, name, #name, val and 1 or 0, err_buf, ERROR_BUF_LEN)

--     if rc ~= 0 then
--         return false, ffi.string(err_buf)
--     end

--     return true
-- end

-- function _M.add_int64_attribute(handle, name, val)
--     local err_buf = get_string_buf(ERROR_BUF_LEN)
--     local rc = clib.lua_resty_protobuf_trace_add_int64_attribute(handle, name, #name, val, err_buf, ERROR_BUF_LEN)

--     if rc ~= 0 then
--         return false, ffi.string(err_buf)
--     end

--     return true
-- end

-- function _M.add_double_attribute(handle, name, val)
--     local err_buf = get_string_buf(ERROR_BUF_LEN)
--     local rc = clib.lua_resty_protobuf_trace_add_double_attribute(handle, name, #name, val, err_buf, ERROR_BUF_LEN)

--     if rc ~= 0 then
--         return false, ffi.string(err_buf)
--     end

--     return true
-- end

-- function _M.exit_span(handle)
--     clib.lua_resty_protobuf_trace_exit_span(handle)
-- end


-- local BUF_INIT_LEN = 4096
-- local BUF_MAX_LEN = 40960
-- local buf_cur_len = BUF_INIT_LEN
-- local buf = ffi.new("uint8_t[?]", buf_cur_len)

-- -- we are not going to call this function now
-- -- as we would like to send the data on the C-land,
-- -- cosocket is not fast enough.
-- function _M.get_serialized(handle)
--     local sz = 0

--     repeat
--         sz = clib.lua_resty_protobuf_trace_get_serialized(handle, buf, buf_cur_len)

--         if sz == 0 then
--             buf_cur_len = buf_cur_len * 2
--             buf = ffi.new("uint8_t[?]", buf_cur_len)
--         end
--     until sz ~= 0

--     local serialized = ffi.string(buf, sz)

--     if buf_cur_len > BUF_MAX_LEN then
--         buf_cur_len = math_floor(buf_cur_len / 2)
--         buf = ffi.new("uint8_t[?]", buf_cur_len)
--     end

--     return serialized
-- end

-- function _M.serialize_log(time_unix_nano, observed_time_unix_nano, message)
--     local buf = ffi.new("uint8_t[?]", 10240)
--     local rc = clib.lua_resty_protobuf_serialize_log(time_unix_nano, observed_time_unix_nano, message, #message, buf, 10240)

--     assert(rc ~= 0, "failed to serialize log")

--     return ffi.string(buf, rc)
-- end

-- function _M.serialize_metrics_gauge(name, time_unix_nano, value)
--     local buf = ffi.new("uint8_t[?]", 10240)
--     local rc = clib.lua_resty_protobuf_serialize_metrics_gauge(name, #name, time_unix_nano, value, buf, 10240)

--     assert(rc ~= 0, "failed to serialize metrics gauge")

--     return ffi.string(buf, rc)
-- end

-- function _M.metrics_new()
--     local handle = clib.lua_resty_protobuf_metrics_new()

--     -- avoid tail call
--     return handle
-- end

-- function _M.metrics_free(handle)
--     clib.lua_resty_protobuf_metrics_free(handle)
-- end

-- function _M.metrics_get_serialized(handle)
--     local sz = 0

--     repeat
--         sz = clib.lua_resty_protobuf_metrics_get_serialized(handle, buf, buf_cur_len)

--         if sz == 0 then
--             buf_cur_len = buf_cur_len * 2
--             buf = ffi.new("uint8_t[?]", buf_cur_len)
--         end
--     until sz ~= 0

--     local serialized = ffi.string(buf, sz)

--     if buf_cur_len > BUF_MAX_LEN then
--         buf_cur_len = math_floor(buf_cur_len / 2)
--         buf = ffi.new("uint8_t[?]", buf_cur_len)
--     end

--     return serialized
-- end

-- function _M.metrics_add_gauge(handle, name, value)
--     local rc = clib.lua_resty_protobuf_metrics_add_gauge(handle, name, #name, math.floor(value))

--     assert(rc == 0, "failed to add gauge")
-- end

-- function _M.metrics_add_sum(handle, name, value)
--     local rc = clib.lua_resty_protobuf_metrics_add_sum(handle, name, #name, math.floor(value))

--     assert(rc == 0, "failed to add sum")
-- end



-- return _M
